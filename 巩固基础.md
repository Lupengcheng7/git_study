# AJAX(Asynchronous Javascript And Xml)

## 1传统请求及缺点

​     缺点：每次请求网页都会重新加载

​     **AJAX最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。**

​     **异步：同时发送多个请求，且请求之间不需要等待**

## 2AJAX概述

![image-20230708195503857](C:\Users\巴黎\AppData\Roaming\Typora\typora-user-images\image-20230708195503857.png)

## 3AJAX工作原理

![image-20230708195738061](C:\Users\巴黎\AppData\Roaming\Typora\typora-user-images\image-20230708195738061.png)

## 4XMLHttpRequest对象

- XMLHttpRequest 是 AJAX 的基础
- XMLHttpRequest 只是实现 Ajax 的一种方式
- XMLHttpRequest对象是AJAX的核心对象，用于发送请求以及接收服务器数据的返回
- 现代浏览器都内置了该对象

### 4.1创建XMLHttpRequest对象

```javascript
const xhr = new window.XMLHttpRequest()
```

### 4.2XMLHttpRequest对象的方法

![image-20230708202613261](C:\Users\巴黎\AppData\Roaming\Typora\typora-user-images\image-20230708202613261.png)

### 4.3XMLHttpRequest对象的属性

![image-20230708202937041](C:\Users\巴黎\AppData\Roaming\Typora\typora-user-images\image-20230708202937041.png)

### 4.4请求示例

```html
<body>
    <input type="button" value="hello2" onclick="loaddata()">
    <script>
        function loaddata() {
            //鼠标单击按钮，触发loaddata事件，创建XMLHttpRequest对象
            let xhr = new window.XMLHttpRequest()
            //注册回调函数，在readyState状态值改变时触发
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4 || xhr.readyState == 200){
                    const btn = document.querySelector('input')
                    btn.value = xhr.responseText
                    console.log(xhr)
                }
            }
            //开启通道
            xhr.open("POST", "http://localhost:9990/sufs/api/shenyang/test", true)
            //发送请求
            xhr.send()
        }
    </script>
</body>
```

## 5AJAX的同步和异步

![image-20230708210211668](C:\Users\巴黎\AppData\Roaming\Typora\typora-user-images\image-20230708210211668.png)

# 前端基础知识

## 1互联网

​     通过TCP/IP协议族相互连接在一起的计算机形成的网络就叫互联网

### 1.1TCP/IP协议

​     TCP是Transmission Control Protocol，传输控制协议；IP是Internet Protocol，网络协议

​      IP用于标识**网络上**的一台计算机，TCP是计算机之间**控制信息传输**的协议（规则）。IP相当于人的身份证，TCP则规定人与人之间沟通的语言和方式，以确保找到特定正确的人并且相互之间可以用相互理解的方式进行信息交流

### 1.2五层网络协议栈

[客户端](https://www.zhihu.com/search?q=客户端&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1644739385})发出http请求到服务器接收，中间会经过一系列的流程。

客户端发送请求具体：从应用层发动http请求，到传输层通过三次握手简历tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后在物理层通过物理介质传输。

服务端接收请求具体：反过来。

五层网络协议：

1、应用层（DNS，HTTP）：DNS解析成IP并发送http请求；

2、传输层（TCP，UDP）：建立TCP连接（3次握手）；

3、网络层（IP，ARP）：IP寻址；

4、数据链路层（PPP）：封装成帧；

5、物理层（利用物理介质传输比特流）：物理传输（通过双绞线，电磁波等各种介质）

## 2域名

  IP地址（Internet Protocol Address）：互联网协议地址，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以便于网络通信

  域名：一组 IP 地址数字很不容易记忆，因此，需要为网上的服务器取一个有意义又容易记忆的名字，这个名字就叫它域名（Domain Name）

## 3DNS

   DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP/IP 网络

   它的作用非常简单，就是**根据域名查出对应的 IP地址**

解析过程：

- 当我们在浏览器地址栏中输入某个[Web服务](https://so.csdn.net/so/search?q=Web服务&spm=1001.2101.3001.7020)器的域名时。用户主机会首先在自己的DNS高速缓存中查找该域名所应的IP地址

- 如果没有找到，则会向ISP（互联网服务提供商）的某台DNS服务器查询，DNS服务器中有域名和IP地映射关系的数据库。当DNS服务器收到DNS查询报文后，在其数据库中查询，之后将查询结果发送给用户主机

- 用户主机中的浏览器可以通过Web服务器的IP地址对其进行访问

## 4服务器

​      为**网络中**的**其他客户机**（PC机、智能手机、[ATM](https://so.csdn.net/so/search?q=ATM&spm=1001.2101.3001.7020)等终端）提供**共享信息资源**和各种**服务**的一种**高性能计算机**（通俗的讲就是一台电脑，只不过性能比普通电脑性能好）

## 5浏览器

### 5.1浏览器加载顺序

- 浏览器加载的时候是自上而下的，渲染的顺序也是从上到下，加载和渲染为同步进行

### 5.2浏览器渲染过程

### 5.3跨域解决方案

#### 5.3.1什么是跨域

​     当一个请求url的**[协议、域名、端口](https://so.csdn.net/so/search?spm=1001.2014.3001.4498&q=协议、域名、端口&t=&u=)**三者之间任意一个与当前页面url不同即为跨域

![image-20230709154445466](C:\Users\巴黎\AppData\Roaming\Typora\typora-user-images\image-20230709154445466.png)

#### 5.3.2为什么出现跨域问题

​		出于浏览器的同源策略限制。**同源策略**是一个重要的安全策略，它用于限制一个[origin](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Glossary/%E6%BA%90)的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介

​       同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的**安全功能**，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。

#### 5.3.3解决方案

   CORS"跨域资源共享"（Cross-origin resource sharing）

### 5.4浏览器缓存机制

​    加快浏览器加载网络资源的速度，一般只缓存静态资源（js、css、img）

#### 5.4.1浏览器缓存分类

按存储位置分：

- Service Worker
- Memory Cache（内存缓存，读取数据高效，持续时间很短，关闭tab页面缓存随即释放，小文件优先存储到内存中）
- Disk Cache（硬盘缓存，读取速度慢，存储量大，使用频率高的缓存到硬盘中）
- Push Cache（推送缓存，**它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂**）

按是否需要向服务器重新发起 HTTP 请求分：

- 强制缓存（强制缓存是在浏览器加载资源的时候，先检查缓存时间是否过期，若未过期则直接从缓存中查找请求结果，如果缓存时间过期或不存在该缓存结果，则向服务端发起请求）  控制它的字段分别是：`Expires`和`Cache-Control`，其中`Cache-Control`优先级比`Expires`高

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461e51029b60422f80cb202242fa6d64~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

```
Cache-Control: max-age=3600 我希望你把这个资源缓存起来，缓存时间是3600秒（1小时）
Expires: Thu, 10 Nov 2020 08:45:11 GMT 到达指定时间过期
Date: Thu, 30 Apr 2020 12:39:56 GMT
```

- 协商缓存（协商缓存不指定缓存的有效时间，而是在请求时直接发送资源标识到服务端确认缓存是否需要更新，如果请求响应返回的 HTTP 状态为 304，则表示缓存仍然有效；否则返回状态码 200 、最新的资源和最新的资源标识。这种缓存可以保证浏览器每次拿到的数据都是最新状态的）

```
Last-Modify/if-Modify-Since:浏览器第一次请求一个资源的时候，服务器返回的header中会加一个Last-Modify，标识这个资源上一次修改的时间；当浏览器再次请求这个资源的时候，请求头中会包含if-Modify-Since标识上一次修改时间，即Last-Modify，服务器根据这个时间和自己手里资源修改时间进行对比，如果相等，则命中协商缓存，返回状态码304，如果状态码为200，表示需要向服务器重新获取数据；

Etag/if-None-Match:etag是一个hash值，web服务器响应请求的时候，告诉浏览器当前资源在服务器上的唯一标识。下次浏览器再次向服务器请求资源的时候就会带着这个etag（保存在if-None-Match字段中）去询问服务器，服务器拿到这个etag之后会和服务器内部的etag进行比对，看是否相等，如果相等，说明资源没被修改，返回状态码304，如果修改了，etag值会发生变化，返回状态码200。

Etag:W/"121-171ca289ebf"，(后面协商缓存内容)这个资源的编号是W/"121-171ca289ebf"
Last-Modified:Thu, 30 Apr 2020 08:16:31 GMT，(后面协商缓存内容)这个资源的上一次修改时间
```

#### 5.4.2浏览器缓存过程

- 浏览器发送请求前，判断是否存在缓存，若存在，进行下一步；如不存在，直接向服务器发送请求

- 根据expires和cache-control判断是否过期，如果未过期，直接从缓存获取资源（强缓存生效），并不会发送请求。如果过期，则进入下一步。 

- 浏览器发送请求，根据last-modified和etag判断是否命中协商缓存，如果命中，返回状态码304，直接从缓存获取资源。如果没有命中，返回状态码为200， 同时携带服务器的最新资源

  ![img](https://pic3.zhimg.com/v2-28160195deb51a7ff988ce0e6fe47996_r.jpg)

### 5.5控制台调试技巧

#### 5.5.1添加断点

- 打开一个文件，中间的面板中显示了代码，代码的左侧有代码行号，代码行号所在的位置叫做行号槽，点击行号槽，为相应的行添加断点，并在相应的行号上面加上一个类似肩章的五边形图标。特别提一下的是，这个图标的颜色是蓝色的。如下：

![image-20240101110646655](C:\Users\24686\AppData\Roaming\Typora\typora-user-images\image-20240101110646655.png)

- 如果一条语句由多行组成，如果在这条语句的行中添加断点的话，那么断点将会被加到下一条语句。举例如下：

![image-20240101110737582](C:\Users\24686\AppData\Roaming\Typora\typora-user-images\image-20240101110737582.png)

- 不能为空行添加断点

![image-20240101110946018](C:\Users\24686\AppData\Roaming\Typora\typora-user-images\image-20240101110946018.png)

- 不能为括号行、变量声明添加断点

![image-20240101110906821](C:\Users\24686\AppData\Roaming\Typora\typora-user-images\image-20240101110906821.png)

![image-20240101112916875](C:\Users\24686\AppData\Roaming\Typora\typora-user-images\image-20240101112916875.png)

#### 5.5.2条件断点

- 右键一个没有添加断点的行号，选择 "Add conditional breakpoint"，输入你的条件，当条件满足时，断点才会生效

![image-20240101112326689](C:\Users\24686\AppData\Roaming\Typora\typora-user-images\image-20240101112326689.png)

#### 5.5.3行内断点

可以在一行内添加多个断点，第 1 个断点跟后 1 个不一样的是，第 1 个断点是默认处于激活状态，而后1 个则不是，点击即可生效

![image-20240101113126744](C:\Users\24686\AppData\Roaming\Typora\typora-user-images\image-20240101113126744.png)

#### 5.5.4断点调试

运行到下一个断点![image-20240101141006310](C:\Users\24686\AppData\Roaming\Typora\typora-user-images\image-20240101141006310.png)

执行下一句，代码会一行一行的往下执行。若为函数，不进入函数内部，会跳过函数![image-20240101114626724](C:\Users\24686\AppData\Roaming\Typora\typora-user-images\image-20240101114626724.png)

执行下一句，代码会一行一行的往下执行。若为函数，则会进入函数内部![image-20240101114728004](C:\Users\24686\AppData\Roaming\Typora\typora-user-images\image-20240101114728004.png)

## 6HTTP

​	HTTP（Hyper Text Transfer Protocol）: 全称超文本传输协议，是一种应用层协议，基于 TCP/IP 通信协议来传递数据的，规定了客户端和服务器之间如何进行通信的规则。其中 HTTP1.0、HTTP1.1、HTTP2.0 均为 TCP 实现，HTTP3.0 基于 UDP 实现。现主流使用 HTTP1.0 和 HTTP3.0

### 6.2常见 HTTP 协议

![image-20230709173147310](image-20230709173147310.png)

![image-20230709173250791](image-20230709173250791.png)

http1.0和http1.1的区别

- 长连接

  在HTTP/1.0中，默认使用的是短连接，也就是说**每次请求都要重新建立一次连接**。 HTTP 是基于TCP/IP协议的,每一次**建立或者断开连接**都需要[三次握手](https://so.csdn.net/so/search?q=三次握手&spm=1001.2101.3001.7020)四次挥手的**开销**，如果每次请求都要这样的话，开销会比较大。HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。

- 错误状态响应码

​       在HTTP1.1中新增了24个错误状态**响应码**，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除

- 缓存处理
  在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
- 带宽优化及网络连接的使用
  HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接

### 6.3HTTP 请求类别

![image-20230709174448780](image-20230709174448780.png)

### 6.4常见状态码

![image-20230709174536601](image-20230709174536601.png)

- 2XX 成功

  200 ok（请求成功）

  204 no content （请求成功，但是没有结果返回）

  206 partial content （客户端请求一部分资源，服务端成功响应，返回一范围资源）

- 3XX 重定向

  301 move permanently （永久性重定向）

  302 found （临时性重定向）

  303 see other （示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源）

  304 not modified （表示在客户端采用带条件的访问某资源时，服务端找到了资源，但是这个请求的条件不符合。跟重定向无关）

  307 temporary redirect （跟302一个意思）

- 4XX 客户端错误

  400 bad request （请求报文存在语法错误）

  401 unauthorized （需要认证（第一次返回）或者认证失败（第二次返回））

  403 forbidden （请求被服务器拒绝了）

  404 not found （服务器上无法找到请求的资源）

- 5XX 服务器错误

  500 internal server error （服务端执行请求时发生了错误）

  503 service unavailable （服务器正在超负载或者停机维护，无法处理请求）

### 6.5常见的Content-Type类型及其描述

![image-20230709171300433](image-20230709171300433.png)

### 6.6Cookie

#### 6.6.1What

   Cookie就是**一些数据**，用于存储服务器返回给客户端的信息，客户端进行保存。在下一次访问该网站时，客户端会将保存的cookie一同发给服务器，服务器再利用cookie进行一些操作。利用cookie我们就可以实现自动登录，保存游览历史，身份验证等功能。

#### 6.6.2why

​    浏览器与WEB服务器之间是使用[HTTP协议](https://www.zhihu.com/search?q=HTTP协议&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1742232484})进行通讯的，而HTTP协议本身是无状态的。什么是[无状态](https://www.zhihu.com/search?q=无状态&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1742232484})呢，即服务器无法判断浏览器身份，即无论浏览器是否已经访问过，服务器都会当成第一次来对待。这时就需要一个能保存访问状态的信息，去告诉服务器我已经访问过你了。而这个信息就可以使用Cookie来保存

#### 6.6.3Cookie的表示

![image-20230709175012316](image-20230709175012316.png)

  一般情况下，cookie是以键值对进行表示的(key-value)，例如name=jack，这个就表示cookie的名字是name，cookie携带的值是jack

#### 6.6.4Cookie的组成

- Name：这个是cookie的名字
- Value：这个是cooke的值
- Path：这个定义了Web站点上可以访问该Cookie的目录
- Expires：这个值表示cookie的过期时间，也就是有效值，cookie在这个值之前都有效。
- Size：这个表示cookie的大小
- HttpOnly：设为true后，只能通过http访问，不能通过document.cookie获取设定为httponly的键值,防止xss读取cookie

#### 6.6.5Cookie的通讯过程

Cookie在通讯中会经历4个过程：

1. 浏览器发送请求
2. 服务端接收请求，并返回响应，在报文头中包含set-cookie的字段
3. 浏览器接收响应后将Cookie存储，并在之后的请求中都会带上cookie的信息。
4. 服务端接收请求，并返回响应。

#### 6.6.6Cookie的生命周期

​	cookie有2种存储方式，一种是会话性，一种是持久性

- 会话性：如果cookie为会话性，那么cookie仅会保存在**客户端的内存中**，当我们关闭客服端时cookie也就失效了
- 持久性：如果cookie为持久性，那么cookie会保存在**用户的硬盘中**，直至生存期结束或者用户主动将其销毁

​     Expire字段为Session为会话性，**有时间则为持久性**

#### 6.6.7Session

​      cookie和[session](https://so.csdn.net/so/search?q=session&spm=1001.2101.3001.7020)都是用来跟踪浏览器用户身份的会话方式

工作原理

- 浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端
- 浏览器端发送第N（N>1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象
- 服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。
- name为JSESSIONID的Cookie不存在（关闭或更换浏览器），返回1中重新去创建Session与特殊的Cookie
- name为JSESSIONID的Cookie存在，根据value中的SessionId去寻找session对象
- value为SessionId不存在**（Session对象默认存活30分钟）**，返回1中重新去创建Session与特殊的Cookie
- value为SessionId存在，返回session对象

#### 6.6.8cookie和session的区别

- cookie数据存放在客户的浏览器上，session数据放在服务器上
- cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session
- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE
- 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K

### 6.7HTTPS

​	HTTPS 经由 HTTP 进行通信，但是在 HTTP 的基础上引入了一个**加密层**，使用 SSL/TLS 来**加密**数据包；目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性

#### 6.7.1加密相关术语

- 明文：要传输的原始的消息
- 密文：通过一定的规则将明文变换后的内容
- 加密：将明文变成密文
- 解密：将密文变成明文
- 密钥：在加密和解密的过程中，往往需要一个或多个中间的数据来辅助该过程，这样的数据称为密钥

#### 6.7.2为什么需要加密

​    通过网络传输的任何数据都会经过运营商的网络设备（路由器、交换机等），那么运营商的网络设备就可以解析出我们传输的数据内容，并进行篡改；故 HTTPS 的出现，使用密文传输进一步的**保证了用户的信息安全**

## 7浏览器从输入URL到页面加载的全过程（一次完整的HTTP请求过程）

7.1浏览器开启网络线程

7.2DNS域名解析

- 当我们在浏览器地址栏中输入某个[Web服务](https://so.csdn.net/so/search?q=Web服务&spm=1001.2101.3001.7020)器的域名时。用户主机会首先在浏览器的DNS高速缓存中查找该域名所应的IP地址
- 如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件（C:\WINDOWS\system32\drivers\etc）看是否存在对应的映射关系,如果存在，则域名解析到此完成。
- 如果没有找到，则会向ISP（互联网服务提供商）的某台DNS服务器查询，DNS服务器中有域名和IP地映射关系的数据库。当DNS服务器收到DNS查询报文后，在其数据库中查询，之后将查询结果发送给用户主机
- 用户主机中的浏览器可以通过Web服务器的IP地址对其进行访问

7.3**建立TCP连接**

​    三次握手

7.4发送HTTP请求

​     一个HTTP请求报文由请求行（request line）、请求头（headers）、空行（blank line）和请求体（request body）4个部分组成

- 请求行   请求行分为三个部分：**请求方法**、**请求地址URL**和**HTTP协议版本**，它们之间用空格分割。例如，GET /index.html HTTP/1.1
- 请求头

- 请求体

  **请求报文示例：**

```markdown
//请求行
POST 　/index.php　HTTP/1.1 　请求方法：POST  请求的资源路径：/index.php  使用的HTTP协议版本：HTTP/1.1
//请求头
Host: localhost  指定服务器的主机名或IP地址
User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　指定发送请求的用户代理（浏览器）信息
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8  指定客户端可接受的响应内容类型及其优先级 //"text/html"和"application/xhtml+xml"没有指定q值，默认为1，表示最高优先级。"application/xml"指定了q值为0.9，表示较高的优先级。而"/"指定了q值为0.8，表示较低的优先级
Accept-Language: zh-cn,zh;q=0.5  指定客户端可接受的响应内容的语言

Accept-Encoding: gzip, deflate  指定客户端可接受的响应内容的压缩方式

Connection: keep-alive  指定客户端与服务器之间保持持久连接

Referer: http://localhost/  指定该请求的来源页面

Content-Length：25  指定请求体（body）的长度

Content-Type：application/x-www-form-urlencoded  指定请求体的媒体类型为表单形式的数据
//请求体
username=aa&password=1234  实际的请求数据，以键值对的形式表示用户的用户名和密码
```

7.5服务器端处理并响应HTTP请求，浏览器获得响应资源

​	一个HTTP响应报文由状态行（status line）、响应头（headers）、空行（blank line）和响应体（response body）4个部分组成

- 状态行  状态行由3部分组成，分别为：协议版本、状态码、状态码描述。其中协议版本与请求报文一致，状态码描述是对状态码的简单描述
- 响应头

![image-20230709165119856](C:\Users\巴黎\AppData\Roaming\Typora\typora-user-images\image-20230709165119856.png)

- 响应体

**响应报文示例：**

```markdown
//状态行
HTTP/1.1 200 OK　　HTTP版本：HTTP/1.1  状态码：200  状态描述：OK
//响应头
Date: Sun, 17 Mar 2013 08:12:54 GMT　　指定响应生成的日期和时间

Server: Apache/2.2.8 (Win32) PHP/5.2.5  指定服务器软件的名称和版本号

X-Powered-By: PHP/5.2.5  指定响应使用的脚本语言及其版本

Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/   设置一个名为PHPSESSID的Cookie，并指定它的值和路径

Expires: Thu, 19 Nov 1981 08:52:00 GMT  指定响应过期的日期和时间

Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0  指定缓存控制指令，禁止缓存和重新验证缓存

Pragma: no-cache  指定缓存指令，禁止缓存

Content-Length: 4393  指定响应体（body）的长度，这里是4393个字节

Keep-Alive: timeout=5, max=100  指定持久连接的参数，超时时间为5秒，最大请求数为100

Connection: Keep-Alive  指定连接类型为持久连接

Content-Type: text/html; charset=utf-8  指定响应体的媒体类型为HTML文档，字符集为UTF-8
//响应体
<html>
<head>
<title>HTTP响应示例<title>
</head>
<body>
Hello HTTP!
</body>
</html>
```

7.6浏览器解析

7.7**浏览器渲染**

   浏览器接收到http数据包后的解析流程（涉及到：html的[词法分析](https://www.zhihu.com/search?q=词法分析&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1644739385})，然后解析成dom树，同时解析css生成css规则树，合并生成render树。然后layout布局、painting渲染、复合图层的合成、GPU绘制、外链接处理、loaded和documentloaded等）

7.7.1HTML 解析和构建 DOM 树

7.7.2样式表加载和构建 CSSOM 树

   浏览器在构建 DOM 树的同时，会解析外部样式表并构建 CSSOM（CSS 对象模型）树。CSSOM 树表示了文档的样式信息，包括每个元素的样式规则。样式表的加载是异步进行的，不会阻塞 HTML 解析

7.7.3构建渲染树

  DOM 树和 CSSOM 树合并构建渲染树（Render Tree）。渲染树只包含需要显示的节点和其样式信息，不包括不可见的节点（如 `<head>` 或样式 `display: none` 的元素）。**渲染树的构建是一个递归过程，涉及到样式继承和层叠等概念**

7.7.4布局（Layout）

  布局阶段确定每个节点在屏幕上的位置和大小。浏览器计算每个元素的盒模型，包括宽度、高度、边距等属性。布局是基于渲染树的，但是在这一阶段，浏览器可能需要回流（reflow）和重绘（repaint）一些元素，以确保它们的位置和大小正确。

7.7.5绘制（Paint）

   绘制阶段将布局阶段计算得到的样式信息应用到屏幕上，形成用户最终看到的页面。绘制通常涉及将像素绘制到屏幕上，包括绘制文本、图像等。

7.7.6合成（Composite）

​    浏览器使用图层（Layer）来优化页面的渲染性能。在合成阶段，浏览器将各个图层合成为最终的页面显示。合成是在 GPU 上进行的，以提高性能。

7.8**关闭TCP连接**

  通过四次挥手释放TCP连接

# Promise

## 1Promise介绍

### 1.1什么是Promise

​	Promise是JS中进行异步编程的**新解决方案**，旧方案是单纯使用回调函数

​    从语法上来说：Promise是一个**构造函数**

​    从功能上来说：Promise对象用来封装一个异步操作并可以获得其成功或失败的结果值

### 1.2为什么要使用Promise

#### 1.2.1指定回调函数的方式更加灵活

- 旧的：必须在启动异步任务前先把回调函数准备好
- promise：启动异步任务=>返回promise对象=>给promise对象绑定回调函数

#### 1.2.2支持链式调用，可以解决回调地狱问题

- 回调地狱：回调函数多层嵌套调用

```javascript
setTimeout(function () {  //第一层
            console.log('武林要以和为贵');
            setTimeout(function () {  //第二程
                console.log('要讲武德');
                setTimeout(function () {   //第三层
                    console.log('不要搞窝里斗');
                }, 1000)
            }, 2000)
        }, 3000)
```

- 不便于阅读，不便于链式调用

## 2Promise初体验

```javascript
//旧的
<body>
    <button id="btn">点击我</button>
    <script>
        function rand(m, n) {
            return Math.ceil(Math.random() * (n - m + 1) + m - 1)
        }

        const btn = document.querySelector('#btn')
        btn.addEventListener('click', () => {
            setTimeout(() => {
                let n = rand(1, 100)
                if (n < 30)
                    alert('恭喜中奖')
                else
                    alert('谢谢惠顾')
            }, 1000)
        })
    </script>
</body>
//新的  Promise
const btn = document.querySelector('#btn')
        btn.addEventListener('click', () => {
            const p = new Promise((resolve, reject) => {
                setTimeout(() => {
                    let n = rand(1, 100)
                    if (n < 80)
                        resolve(n)   //将promise对象的状态设置为 成功  并将异步任务成功后的结果值传给resolve
                    else
                        reject(n)   //将promise对象的状态设置为 失败  并将异步任务失败后的结果值传给reject
                }, 1000)
            })
            p.then((value) => {
                alert(`恭喜中奖，您的中奖数字为${value}`)
            }, (reason) => {
                alert(`谢谢惠顾,，您的号码为${reason}`)
            })
        })
```

## 3Promise对象属性

### 3.1状态属性PromiseState

​    pending（未决定的）、resolved/fulfilled、rejected

- 一个Promise对象只能改变一次状态，只能由pending变为resolved或pending变为rejected
- 只有当状态属性变化时，Promise对象会同时执行多个成功/失败回调函数

### 3.2结果值属性PromiseResult

  保存异步任务成功/失败的结果

## 4Promise构造函数和对象方法

### 4.1Promise构造函数

   Promise(excutor)    executor = (resolve, reject) => { } 

- executor函数会在Promise内部立即同步调用，异步操作在执行器中使用
- resolve函数
- reject函数

### 4.2then方法

​    返回一个Promise对象

### 4.3catch方法

## 5Promise链式调用

## 6Promise封装AJAX请求

```javascript
        function sendAJAX(url) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest()
                xhr.onreadystatechange = function() {
                    if (xhr.readyState == 4) {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            resolve(xhr.response)
                        }
                        else {
                            reject(xhr.status)
                        }
                    }
                }
                xhr.open('GET', url)
                xhr.send()
            })
        }
        sendAJAX("/test").then(value => {
            alert(value)
        }, reason => {
            alert(reason)
        })
```

## 7async函数

   返回一个Promise对象

# Axios

## 1Axios是什么

​	Axios是一个**基于Promise的HTTP库**，可以用在浏览器和node.js中，可以发送get、post等请求

​	**AJAX是对原生XHR的封装**，**而Axios和JQuery AJAX都是对AJAX的封装**

## 2为什么要使用Axios

### 2.1AJAX的缺点

- ajax不能使用Back和history功能，即对浏览器机制的破坏
- 安全问题 ajax暴露了与服务器交互的细节
- 对收索引擎的支持比较弱
- 破坏程序的异常处理机制
- 违背URL和资源定位的初衷
- ajax不能很好的支持移动设备
- 太多客户端代码造成开发上的成本

### 2.2Axios的优点

- **在浏览器中创建 XMLHttpRequest**
- **在node.js则创建http请求**
- **支持Promise API**
- **支持拦截请求和响应**
- **转换请求和响应数据**
- 取消请求
- **自动转换成JSON数据格式**
- 客户端支持防御XSRF

## 3Axios基本使用

### 3.1提供方法

```
axios(config)

axios.request(config)

axios.get(url[, config])

axios.delete(url[, config])

axios.head(url[, config])

axios.post(url[, data[, config]])

axios.put(url[, data[, config]])

axios.patch(url[, data[, config]])
```

### 3.2config配置信息

```
{
  // `url` 是对应访问服务器的请求
  url: '/user',

  // `method` 用于设置请求方法，默认是get
  method: 'get', // default

  //设置路径url的统一前缀
  baseURL: 'https://some-domain.com/api/',

  //`params`是以URL中?后的参数形式提交 
  params: {
    ID: 12345
  },

  //data数据会放入request body中
  //支持request methods：'PUT', 'POST', 'DELETE ,  'PATCH'
  data: {
    firstName: 'Fred'
  },
  
  //method为post提交方式，以字符串放入请求体中，没有key 
  data: 'Country=Brasil&City=Belo Horizonte',

  // `timeout` specifies the number of milliseconds before the request times out.
  // If the request takes longer than `timeout`, the request will be aborted.
  timeout: 1000, // default is `0` (no timeout)

  // `responseType` 设置服务器返回数据类型，默认是json，一般不用改动
  // 可用项: 'arraybuffer', 'document', 'json', 'text', 'stream'
  responseType: 'json' // default
}
```

### 3.3response响应对象

```
{
  // `data`是服务器提供的响应信息 
  data: {},

  // `status` 是HTTP的响应状态码
  status: 200,

  // `statusText`是HTTP的响应文本信息 
  statusText: 'OK',

  // `headers` 响应信息的HTTP的headers 
  headers: {},

  // `config`是axios请求中的配置对象信息 request
  config: {},

  // `request` 是原生XHR请求对象信息 
  request: {}
}
```

### 3.4默认全局配置

​	可以设置全局默认配置，是为了避免多种重复配置在不同请求中重复，比如baseURL、timeout等

```
axios.defaults.baseURL = 'https://api.example.com';
axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;
axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';
```

**配置的优先级**

​    配置将会按优先级进行合并。它的顺序是：在 lib/defaults.js 中找到的库默认值，然后是实例的 **`defaults`** 属性，最后是请求的 **`config`** 参数。**后面的优先级要高于前面的**。

*优先级：库默认配置<axios默认全局配置 < axios实例配置 < axios请求配置*

### 3.5创建实例对象

   配置独立性：不同的Axios实例对象之间是相互独立的，每个实例对象都可以有自己的默认配置和拦截器。这样可以根据不同的需求和场景（多服务器）创建多个实例对象，各自独立管理和配置

```
const instance = axios.create({
  baseURL: 'https://some-domain.com/api/',
  timeout: 1000,
  headers: {'X-Custom-Header': 'foobar'}
});
```

## 4拦截器

​	在请求或响应被 then 或 catch 处理前拦截它们，对它们做进一步处理

### 4.1请求拦截器

```
    //   请求拦截器
    axios.interceptors.request.use(config => {
      // 在发送请求前做些什么
      return config;
    }, err=>{
        // 在请求错误的时候的逻辑处理
        return Promise.reject(err)
    });
```

### 4.2响应拦截器

```
    // 响应拦截器
    axios.interceptors.response.use(res => {
      // 在请求成功后的数据处理
      return res;
    }, err=>{
        // 在响应错误的时候的逻辑处理
        return Promise.reject(err)
    });
```

## 5源码解析

### 5.1axios创建过程

![image-20231229205024023](image-20231229205024023.png)

### 5.2请求发送过程

​    ①axios调用request()方法   ②执行request方法体里的dispachRequest方法  ③dispatchRequest方法调用xhrAdapter函数，xhrAdapter函数返回promise对象，promise对象1的值为处理后的响应数据  ④dispatchRequest方法返回promise对象2，值为promise对象1的值  ⑤request方法返回promise对象3，值为promise对象2的值

### 5.3拦截器工作流程

![image-20231230144533703](image-20231230144533703.png)

​    ①把use里传递的拦截器函数存储到InterceptorManaher()实例对象的handler属性中

​    ②遍历handler数组，将拦截器函数放入chains数组中去，请求拦截器函数放dispatchRequest函数前面，响应拦截器其放后面

​    ③遍历chains数组，依次执行拦截器函数

### 5.4取消请求工作原理



### 5.5源码总结

#### 5.5.1axios与Axios的区别

- 在语法上来说，axios不是Axios的实例
- 从功能上看，axios是Axios的实例
- axios作为函数，是Axios.prototype.request函数bind()返回的函数
- axios作为对象，包含实例对象的所有属性以及Axios原型对象的所有方法







