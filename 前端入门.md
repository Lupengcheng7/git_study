

# HTML

网站是网页的集合；网页是通常由图片、链接、文字、声音、视频等元素组成，常以.htm或.html后缀结尾的文件;

## 1什么是HTML

​    超文本标记语言（Hyper Text Markup Language）,用来描述网页的一种语言；不是编程语言，而是一种标记语言。

​    超文本：可以加入图片、声音、动画、多媒体等内容（超越了文本限制）

## 2浏览器内核

   渲染引擎，负责读取网页内容，整理讯息，**解析.html文件并渲染显示页面**

   Emmet语法：Emmet语法的前身是Zen coding,它**使用缩写,来提高HTML/CSS的编写速度**,VScode内部已经集成该语法

   浏览器工作流程：浏览器进程中的网络线程请求获取到html数据后，通过IPC将数据传给渲染器进程的主线程，主线程将html解析构造dom树，然后进行样式计算，根据dom树和生成好的样式生成layout树。。。

![image-20231222190440535](image-20231222190440535.png)

## 3Web标准

### 3.1构成

   主要包括结构、表现、行为三个方面

### 3.2为什么需要web标准

   让不同的开发人员写出的页面**更标准、更统一、更规范**

## 4常用标签

### 4.1常用标签

```html
<!DOCTYPE html>  文档类型声明标签
<html lang="zh-CN"></html>  页面中最大的标签，其中lang用来告诉浏览器这是个中文网站，本页面采用中文来显示
<head></head>
<meta charset="UTF-8"/>
<title></title>
<body></body>  页面内容都放在里面
```

```html
<h1>~<h6>  标题标签，文字加粗、独占一行、由大到小
<p></p>  段落标签，paragraph;将文字分段落
<br/>   换行标签，是单标签；
```

```html
文本格式化标签
<strong></strong>  <b></b>   加粗标签
<em></em>  <i></i>  倾斜标签
<del></del>  <s></s> 删除线
<ins></ins>  <u></u> 下划线
```

```html
容器标签
<div></div>  独占一行
<span></span>  一行可多个
```

```html
<img src="图像url，可以是网页地址或本地图片目录地址，必须属性" alt="替换文本，图片不能正常显示后的信息" title="提示文本 鼠标放到图像上显示的文字"/>   图像标签
<a href="指定链接目标的url地址，可以是网页地址、本地html文件、空链接、下载链接（文件或压缩包）、网页元素链接（文本、图像、音频、视频等），必须属性" target="链接页面的打开方式,值默认为_self表示当前、_blank"></a>  超链接标签
<a href="#名字"></a>  <h id="名字"></h>   锚点链接，快速定位
```

```html
特殊字符
&nbsp;  空格符
&lt;  小于号
&gt;  大于号
```

```html
表格标签
用于显示、展示数据
<table aligh="表格在浏览器中的位置" border="有无边框" cellspacing="单元格与单元格间的距离">
    <thead>
        <tr>
            <th>加粗并居中</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>无样式</td>
        </tr>
    </tbody>
</table>
合并单元格 colspan/rowspan
```

```html
列表标签
用于布局

```

### 4.2列表标签

​     用于布局

#### 4.2.1无序列表

​     没有顺序

​     ul中只能放li

```html
<ul>
    <li></li>
    <li></li>
</ul>
```

#### 4.2.2有序列表

有顺序

```html
<ol>
    <li></li>
    <li></li>
</ol>
```

#### 4.2.3自定义列表

```html
<dl>
    <dt></dt>
    <dd></dd>
    <dd></dd>
</dl>
```

### 4.3表单

```html
<form action="" method="" >
    <input type="text/password/radio/checkbox/submit/reset/button/file" name="" value="" checked="checked"/>  单选、复选按钮必须有相同的name属性值
    <label for="其他标签id属性值"></label> <label for="nan">姓名</label><input type="text" id="nan">
    <select>
        <option></option>
        <option selected="selected"></option>
        ......
    </select>
    <textarea>
        文本内容
    </textarea>
</form>
```

#### 4.3.1input标签

#### 4.3.2select标签

#### 4.3.3textarea文本域标签

## 5HTML5新特性

​      1新增标签(语义化标签 多媒体标签 画布标签)  2webStorage本地存储(localStorage sessionStorage)  3表单属性和input类型 4应用缓存

### 5.1语义化标签

```html
<header></header>  头部标签
<nav></nav>  导航栏标签
<article></article>  内容标签
<aside></aside>  侧边栏标签
<footer></footer>  尾部标签
```

### 5.2多媒体标签(音频标签和视频标签)

```html
<video src="文件地址"></video>
<video src="./超链接素材/1648280312588.mp4" controls="controls" autoplay="autoplay" loop="loop"></video>
<audio src=""></audio>
<audio src="./超链接素材/break.mp3" loop="loop" autoplay="autoplay" controls="controls"></audio>
```

### 5.3新增的input类型

```html
type="email"  必须是Email类型
type="url"
type="date"
type="number"
type="tel"
type="search"
type="color"
```

### 5.4新增的表单属性

  required:必须输入

 placeholder:

 autofocus:自动获取焦点

 autocomplete

 multiple:文件可多选

### 5.5canvas画布标签

   画布,用于图形的绘制,通过javascript来完成

### 5.6HTML5 web 存储

  对本地离线存储的更好的支持,可以在本地存储用户的浏览数据  数据以 键/值 对存在

  localStorage 和 sessionStorage \

### 5.7应用程序缓存

​    使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本

​    应用程序缓存为应用带来三个优势：

1. 离线浏览 - 用户可在应用离线时使用它们
2. 速度 - 已缓存资源加载得更快
3. 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源

# CSS

## 1什么是CSS

   层叠样式表（Cascading Style Sheets），一种标记语言，用于美化网页，用于设置页面的文本内容、图片外形以及版面布局和外观显示样式       **CSS=外观样式+布局**

## 2语法规范

​    选择器 {一条或多条样式声明（样式属性：属性值；）}

```css
  <style>
        h2 {
            color: red;
            }
  </style>
```

## 3CSS选择器  

​     用于选择特定标签

### 3.1基础选择器（单个选择器组成）

#### 3.1.1标签选择器

```css
选择所有h2标签
h2 {
    color: red;
   }
选择所有div标签
div {
    color: blue;
}
```

#### 3.1.2类选择器

```css
类命名规则
多类名：一个标签可以有多个类，同时具有这些类的样式，可以减少代码冗余
.sex {
    color: red;
}
.font {
    font-size: 20px;
}
<div class="sex font20">男</div>
```

#### 3.1.3id选择器

```css
id是唯一的，不同标签id应不同
#nav {
    color: red;
}
<div id="nav"></div>
```

#### 3.1.4通配符选择器

​    选取页面中所有标签

### 3.2复合选择器

​    由两个或多个基础选择器组合而成

#### 3.2.1后代选择器

  元素1 元素2 {样式说明}

  元素1的所有后代

#### 3.2.2子选择器

  元素1的亲儿子，不可以是孙子等后代

#### 3.2.3并集选择器

 元素1/选择器1，元素2/选择器2 {样式声明}

```html
<ul class="nav">
    <li></li>
    <li><a></a></li>
</ul>
<ul>
    <li></li>
    <li><a></a></li>
</ul>
```

```css
ul li a {
    color: red;
}
.nav li a {
    color: red;
}
ul > li {
    color: red;
}
.nav li a, .nav li {
    color: red;
}
```

#### 3.2.4伪类选择器 

​    **为处于特定状态的的标签添加样式**

静态伪类：只能用于超链接的样式

- `:link` 超链接点击之前
- `:visited` 链接被访问过之后

动态伪类：针对**所有标签**都适用的样式

- `:hover` “悬停”：鼠标放到标签上的时候
- `:active` “激活”： 鼠标点击标签，但是不松手时。
- `:focus` 是某个标签获得焦点时的样式（比如某个输入框获得焦点）



- 链接伪类选择器

​     a:link  未访问的链接

​     a:visted  已经访问过的链接

​     a:hover  鼠标经过的那个链接

​     a:active  鼠标正在按下的那个链接

- focus伪类选择器

​     input:focus  获得焦点的表单元素

## 4CSS属性

### 4.1字体属性

#### 4.1.1字体系列

​    逗号分割，按前后顺序优先加载，没有字体加载下一个

#### 4.1.2字体大小

​     标题标签比较特殊，需要单独指定文字大小

#### 4.1.3字体粗细

​     normal/bold/border/数字

​     让加粗的不加粗：normal

#### 4.1.4文字样式

​     normal/italic

​    让倾斜的字体不倾斜：normal

#### 4.1.5复合形式

  font: font-style font-weight font-size font-family  顺序不可颠倒，用空格隔开

```css
h2 {
    font-family: '宋体', '微软雅黑';
    font-size: 20px;
    font-weight: 200;
    font-style: italic;
    font: italic 200 20px '宋体'
}
```

### 4.2文本属性

#### 4.2.1文本颜色

#### 4.2.2水平对齐文本

#### 4.2.3装饰文本

#### 4.2.4文本缩进

#### 4.2.5文本行间距

​     上间距+下间距+文本高度

```css
div {
    color: red/#000000/rgb(255,255,255);
    text-align：center/left/right;
    text-decoration: none/underline/overline/line-through;
    text-indent: 2em;
    line-height: 26px;
}
```

### 4.3背景属性

#### 4.3.1背景颜色

​    background-color: transparent/color（red、十六进制、rgb()、rgba()）

#### 4.3.2背景图片

​    background-image: none/图片url

#### 4.3.3背景平铺

​    background-repeat: repeat/no-repeat/repeat-x/repeat-y

#### 4.3.4背景图片位置

​    background-position: top|center|bottom/left|center|right

​                                           x y;  

​                                           x top|center|bottom;

​                                           left|center|right y;

​    eg: top left; 20px 50px; 20px top; left 20px;

#### 4.3.5背景图像固定

​    background-attachment: scrool/fixed

#### 4.3.6复合写法

​    background: 背景颜色 背景图片 背景图片地址 背景平铺 背景图像滚动 背景图片位置

#### 4.3.7背景颜色半透明

​    background: rgba(0,0,0,0.5)

### 4.4单位

​    px、em、rem

px:绝对单位，代表屏幕中每个「点」( pixel )

em:相对单位，每个子元素通过「倍数」乘以**父元素**的px值

rem:相对单位，每个元素通过「倍数」乘以**根元素**的px值

```html
<div style="font-size:1.2em;">1.2em
    <div style="font-size:1.2em;">1.2em
        <div style="font-size:1.2em;">1.2em
            <div style="font-size:1.2em;">1.2em
                <div style="font-size:1.2em;">1.2em</div>
            </div>
        </div>
    </div>
</div>
```

```html
<div style="font-size:1.2rem;">1.2rem
    <div style="font-size:1.2rem;">1.2rem
        <div style="font-size:1.2rem;">1.2rem
            <div style="font-size:1.2rem;">1.2rem
                <div style="font-size:1.2rem;">1.2rem</div>
            </div>
        </div>
    </div>
</div>
```

![image-20231214223834142](image-20231214223834142.png)

## 5CSS引入方式

### 5.1内部样式表

​     写在html页面中，写在<style>标签中

### 5.2行内样式表

​     写在标签中，style属性内

### 5.3外部样式表

​     样式单独写到CSS文件中

```html
<head>
    <link rel="stylesheet" href="路径">
</head>
```

## 6Emmet语法

   提高html/css的编写速度

- 生成标签，直接输入标签名，按tab键即可
- 生成多个相同标签，加上*,按tab键即可
- 父子级关系的标签，可以用 >,比如ul>li
- 兄弟级关系的标签，用+连接，比如div+p
- 带有类名或id的标签，比如div.one、span#two
- 样式属性首字母+属性值：w100=width: 100px;

## 7CSS元素显示模式

### 7.1what

   元素以什么方式显示

### 7.2分类

   块元素、 行内元素、行内块元素

**不管块级元素还是行内元素，区别:一是排列方式，二是宽高边距设置，三是默认宽度，四是包含内容**。

- 块级元素会独占一行，而内联元素和内联块元素则会在一行内显示；
- 块级元素和内联块元素可设置 width、height 属性，而内联元素设置无效；
- 块级元素的 width 默认为 100%，而内联元素则是根据其自身的内容或子元素来决定其宽度

![image-20231215124815414](image-20231215124815414.png)

#### 7.2.1块元素

- 独占一行，比如**div、标题标签**、ul、ol
- 高度、宽度、内外边距都可以控制，
- **元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度的100%）**
- 是一个容器，可以放行内和块元素，但p和h内不能放div等块元素

#### 7.2.2行内元素

- 一行可显示多个，如**span、a**
- 高、宽直接设置是无效的 
- 高度由元素内部的字体大小决定，但字体的大小并不等于高度；默认宽度等于本身内容的宽度
- 只能放文本或其他行内元素，a可以放块元素但不可再放a

#### 7.2.3行内块元素

- 一行可显示多个，如**input、img**
- 高度、行高、内外边距可以控制
- **默认宽高就是它本身内容的宽高**

### 7.3元素显示模式转换

​    display：block;   转成块元素

​    display：inline;   转成行内元素

​    display：inline-block；  转成行内块元素

## 8CSS三大特性

### 8.1层叠性

​    相同属性设置不同的属性值，即样式冲突；采用就近原则，离哪个样式近就执行哪个样式

```css
border: 10px solid red;
border-left: 10px solid blue;
```

### 8.2继承性

​    子标签会自动继承父标签的某些样式，如**文本颜色、字号、行高**

### 8.3优先级

​     选择的同一个标签但选择器不同时，按权重来决定

​     **!important(无穷大)**>行内样式(1,0,0,0)>ID选择器(0,1,0,0)>类选择器、伪类选择器(0,0,1,0)>标签选择器(0,0,0,1)>继承、*(0,0,0,0) 

​     复合选择器存在权重叠加

​     叠加规则：0,0,1,0+0,0,1,1=0,0,2,1

```html
<ul class='nav'>
    <li></li>
    <li></li>
</ul>
```

```css
li {
    color: green;
}
ul li {
    color: blue;
}
.nav li {
    color: pink;
}
```

## 9CSS盒子模型

### 9.1网页布局的过程和本质

#### 9.1.1过程

- 准备好相关的网页元素，即盒子
- 利用CSS设置好盒子样式，然后摆放到相应位置
- 往盒子里装内容

#### 9.1.2本质

​    摆盒子

### 9.2盒子模型的组成

  边框border、内边距padding、外边距margin、内容content

![image-20231215132523718](image-20231215132523718.png)

**重要:** 当您指定一个 CSS 元素的宽度和高度属性时，你只是设置内容区域content的宽度和高度

#### 9.2.1边框border

​    边框粗细会影响盒子实际大小，盒子实际宽度=width+border*2

```css
border-width: 5px; 边框粗细
border-style: solid/dashed/dotted; 边框样式
border-color: red; 边框颜色
border: 1px solid red; 没有顺序
border-left|border-top|border-bottom|border-right: 
border-collapse: collapse;  合并边框
border-radius: 10px半径;  圆角边框，可生成圆角矩形、圆形
```

#### 9.2.2内边距padding

​    边框与内容的距离，会影响盒子的实际大小，使盒子变大

​    **如果没有指定width/height,则不会影响盒子大小**

```css
padding-left
padding-right
padding-bottom
padding-top
padding:10px; 上下左右都为10px
padding:2px 5px;  上下2px，左右5px
```

#### 9.2.3外边距margin

```css
margin-left
margin-right
margin-bottom
margin-top
margin:10px; 上下左右都为10px
margin: 0 auto;  使块盒子水平居中
```

### 9.3清除内外边距

```css
* {
    margin: 0;
    padding: 0;
}
```

### 9.4其他效果

#### 9.4.1盒子阴影

box-shadow

#### 9.4.2文字阴影

text-shadow

## 10CSS浮动

### 10.1传统盒子的布局方式

- 标准流  按规定默认方式排列，即块元素、行内元素、行内块元素
- 浮动  
- 定位

### 10.2为什么需要浮动

-  改变标签默认的布局方式，**可以让多个块级元素一行显示，且块级元素之间不留缝隙**（行内块元素间有缝隙）
-  实现盒子的左右对齐

### 10.3语法

  选择器 {float: left/right/none;}

  float创建浮动框，将其移动到一边，直到左边边缘或右边边缘触及包含块或另一个浮动框的边缘

### 10.4浮动特性

1脱离标准流的控制(脱标)

- 浮动的盒子**不再保留原先的位置**
- 浮动的盒子**不会影响前面的标准流，会影响后面的标准流**

![image-20231215142506497](image-20231215142506497.png)

![image-20231215142450110](image-20231215142450110.png)

2多个浮动盒子会一行内紧挨（无缝隙）显示

3浮动元素具有**行内块元素特性（行内元素设置浮动后，可以设置宽高）**

### 10.5清除浮动

​    清除浮动元素脱离标准流所带来的影响

​    为什么：

#### 10.5.1额外标签法

​    选择新增标签的选择器 {clear: left/right/both}

#### 10.5.2父级添加overflow

​    overflow: hidden

#### 10.5.3:after伪元素 

#### 10.5.4双伪元素

## 11定位

### 11.1为什么使用定位

- 让盒子在某个盒子内**自由移动**位置或**固定**在某一位置，并且可以**压住**其他盒子

### 11.2定位组成

​     定位模式+边偏移

#### 11.2.1定位模式

​     position属性来设置

- static 静态定位
- relative 相对定位
- absolute 绝对定位
- fixed 固定定位

#### 11.2.2边偏移

- top
- bottom
- left
- right

### 11.3静态定位static

​    按标准流特性摆放位置

### 11.4相对定位relative

- 移动位置参照自己原来的位置
- **移动后继续占有原来位置**

### 11.5绝对定位absolute

- 如果没有祖先元素或祖先元素没有定位，则以浏览器为准进行定位
- 如果祖先元素有定位，则**以最近一级的有定位的祖先元素**为准进行定位
- **移动后不占有原来位置**

子绝父相的由来：

### 11.6固定定位fixed

- 以浏览器的**可视窗口**作为参照进行定位
- 移动后不占有原来位置
- 固定到版心右侧：

### 11.7粘性定位sticky

### 11.8定位的叠放次序z-index

​     **只有定位的盒子有这个属性，标准流和浮动没有**

### 11.9一些技巧

#### 11.9.1绝对定位的盒子水平居中

​    position: absolute;

​    left: 50%;

​    margin-left: 盒子一半的负数；

### 11.10定位的特性

- 行内元素添加绝对或固定定位，可设置宽度、高度
- 块级元素添加绝对或固定定位，如不给宽度或高度，默认大小是内容的大小
- 绝对或固定定位会压住标准流的所有内容，浮动不会压住标准流里面的文字



## 12元素的显示和隐藏

### 12.1display属性

  显示 display: block  

  隐藏 display: none  不再占有原来位置

### 12.2visibility属性

  显示 visibility: visible  占有原来位置

  隐藏 visibility: hidden

### 12.3overflow属性

  显示 overflow: visible

  隐藏 overflow: hidden

## 13精灵图

### 13.1为什么需要精灵图

   为了有效减少服务器接收和发送请求的次数，提升页面的加载速度

### 13.2核心原理

​    将网页中的一些小背景图像整合到一张大图上，这样服务器就只需请求一次

### 13.3使用

- 移动背景图片位置，使用background-position
- 通过x、y移动位置来匹配位置

## 14 网页布局总结

### 14.1布局方式

​    一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专业用法

#### 14.1.1标准流

​    可以让盒子上下排列或左右排列，**垂直的块级盒子就用标准流布局**

#### 14.1.2浮动

​    可以让块级盒子一行显示或左右对齐盒子，**多个块级盒子水平显示就用浮动布局**

#### 14.1.3定位

​    可以让多个盒子前后**叠压显示**，**盒子自由移动在某个盒子中或固定在可视窗口某一位置就用定位布局**

### 14.2网络布局三大准则

- 多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动（先用标准流作为父盒子上下排列，子盒子设置为浮动左右排列）
- 先设置盒子大小，再设置盒子位置

## 15CSS3新特性

### 15.1过渡transition

### 15.2盒子模型border-box

### 15.3结构伪类选择器

### 15.4动画

### 15.52D、3D转换

# JavaScript

## 1JavaScrip介绍

### 1.1是什么

​     是一种运行在浏览器的编程语言，实现人机交互效果 

### 1.2为什么要用（作用）

- 网页特效（监听用户的一些行为让浏览器作出对应的反馈）
- 表单验证（针对表单数据的合法性进行判断）
- 数据交互（获取后台的数据，渲染到前端）
- 服务端编程（node.js）

### 1.3组成

​    ![image-20230706201625496](C:\Users\巴黎\AppData\Roaming\Typora\typora-user-images\image-20230706201625496.png)

### 1.4js书写位置

#### 1.4.1内部js

   script标签写在</body>上面

  原因：浏览器会按照代码在文件中的顺序加载html

#### 1.4.2外部js

  代码写在.js结尾的文件里，需通过script标签引入到html页面中

  script标签中间代码会被忽略。

#### 1.4.3内联javascript

   写在标签内部

## 2基础语法

### 2.1输入和输出语法

#### 2.1.1输出

- document.write()   向文档body内输出内容

```javascript
document.write("<h1>你好！</h1>")
```

- alert()  浏览器弹出警告对话框
- console.log()    浏览器控制台打印输出

#### 2.1.2输入

- prompt()

### 2.2js代码执行顺序

   按HTML文档流顺序执行Js代码

   alert()和prompt()会跳过渲染先被执行

### 2.3字面量

​    数据

#### 2.3.1数字字面量Number

   数字字面量可以是整数、小数或者科学计数

#### 2.3.2字符串字面量String

   可以使用单引号或双引号  "John Doe"、'John Doe'

   可以在字符串中使用引号，只要不匹配包围字符串的引号即可：var answer="He is called 'Johnny'";  var answer='He is called "Johnny"';

#### 2.3.3数组字面量Array

   [40, 100, 1, 5, 25, 10]

#### 2.3.4对象字面量Object

   {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"}

### 2.4变量

​     存储数据的容器      本质：是程序在内存中申请的一块用来存放数据的小空间

#### 2.4.1变量的声明和赋值

```javascript
let age
age = 18
let sex = '男'
let age =18, uname = '小红'
```

var和let的区别

var声明

- 可以先使用再声明
- 声明过的变量可以重复声明
- 无块级作用域

#### 2.4.2变量的命名规则

- 不能用关键字
- 只能用下划线、字母、数字、$组成，且数字不能开头
- 严格区分大小写

### 2.5常量

   使用const声明的变量称为常量，当某个变量的值永远不会改变时，可以使用const声明；引用数据类型对应的变量增删改时，可以用const声明

   **常量不允许重新赋值，声明的时候必须赋值**

为什么要划分常量和变量？

### 2.6数据类型

   js是一种弱数据类型语言，分为基本数据类型和引用数据类型，基础数据类型对应的变量存储的是值本身，引用数据类型对应的变量存储的是地址

#### 2.6.1基本数据类型

- 数字类型number   整数、小数、正数、负数、科学计数法
- **字符串类型string**   单引号、双引号包围   单双引号必须成对使用、单双引号可以互相嵌套

​               模板字符串：

```javascript
let age = 14, age1 = 14
let str = `我今年${age + age1}岁了`  // ${表达式}
```

- 布尔类型boolean  只有两个值true和false
- 未定义类型undefined  声明一个变量但未赋值，表示变量不含有值    使用情景：不知道数据是否传递过来，通过检测变量是否undefined，判断用户是否有数据传递过来
- 空类型null  

#### 2.6.2引用数据类型

- 数组   数组可以存放不同数据类型的数据，可以在一个数组中包含对象元素、函数、数组  使用情景：将多个数据保存到一个变量中去
- 对象  js万物皆对象，JavaScript 中的所有事物都是对象：字符串、数值、数组、函数...

**this的指向**

首先理解①this永远指向一个对象 ②this的指向完全取决于函数调用的位置（谁调用我，我的this就指向谁)

**this使用的五种情况：**

①普通函数中的this

```javascript
function getVal() {
	console.log(this); //window
}
```

②构造函数中的this

  构造函数是window对象的方法，如果不用new操作符而直接调用，那么构造函数的执行对象就 是window，即this指向了window。现在用new操作符后，this就指向了新生成的对象

③对象方法中的this

  如果函数是声明式函数，则this为当前对象，如果函数是箭头函数，则this去上一级作用域链找

```javascript
const obj = {
	name: 'xiaohong',
	age: 18,
	description: function() {
		console.log(this); // obj
	}
}
obj.description();


const obj2 = {
	name: 'xiaohong',
	age: 18,
	description: () => {
		console.log(this); //window
	}
}
obj2.description();
```

④事件绑定中的this

```javascript
//行内绑定
<input type="button" value="按钮" onclick="clickFun()">
<script>
    function clickFun(){
        this // 此函数的运行环境在全局window对象下，因此this指向window;
    }
</script>
​
<input type="button" value="按钮" onclick="this">
<!-- 运行环境在节点对象中，因此this指向本节点对象 -->
 
//动态绑定
<input type="button" value="按钮" id="btn">
<script>
    var btn = document.getElementById('btn');
    btn.onclick = function(){
        this ;  // this指向本节点对象
    }
</script>
```

⑤call、apply、bind改变this

```javascript

```

⑥箭头函数中的this



- 函数  定义、传参、调用

```javascript
function functionname (arg1, arg2, arg3 = 10...) {
    代码块
}
// 匿名函数
let fn = function () {
    代码块
}
fn()
```

### 2.7运算符

#### 2.7.1算术运算符

#### 2.7.2赋值运算符

#### 2.7.3比较运算符

#### 2.7.4逻辑运算符

​     && || !

#### 2.7.5自增运算符

​     ++  --

#### 2.7.6运算符优先级

![image-20230706222357221](C:\Users\巴黎\AppData\Roaming\Typora\typora-user-images\image-20230706222357221.png)

### 2.8控制语句

#### 2.8.1条件语句

- if语句
- if...else语句
- if...else if...else语句
- switch...case语句

```javascript
if (age < 17) {
    if (age1 < 1) {
        age = 1;
    }
    else if (age1 >= 1) {
        age = 2;
    }
    else {
        age = 3;
    }
}
switch (age):
    case 1:代码块1;
    break;
    ...
    defaule: ;
```

#### 2.8.2循环语句

- while语句
- for语句
- for...in语句
- do...while语句

### 2.9深拷贝和浅拷贝

​    深拷贝和浅拷贝是两种不同的对象复制方式

需要注意的是：

- **深拷贝/浅拷贝的概念只存在于对象**
- 下面这种操作，既不是深拷贝，也不是浅拷贝

```javascript
var a = {
    name: 'brynn',
    address: {
        provi: 'HN',
        city: 'CS'
    }
};
var b = a;
```

2.9.1浅拷贝

​      指创建一个新对象，将原始对象的属性值复制到新对象中。但是，如果原始对象的属性值是对象引用，浅拷贝将复制引用而不是对象本身。这意味着新对象和原始对象会共享相同的引用类型的属性。

```javascript
// 浅拷贝相当于下述代码
var a = {
    name: 'brynn',
    address: {
        provi: 'HN',
        city: 'CS'
    }
};
var b = {};
b.name = a.name;
b.address = a.address;
// 以下方式可以实现浅拷贝
// 使用扩展运算符
const originalObject = { a: 1, b: { c: 2 } };
const shallowCopy = { ...originalObject };
originalObject.a = 2
originalObject.b.c = 3
console.log(originalObject, shallowCopy)  //{a: 2，b: {c: 3}}  {a: 1，b: {c: 3}}
// Object.assign()
const originalObject = { a: 1, b: { c: 2 } };
const shallowCopy = Object.assign({}, originalObject);
```

2.9.2深拷贝

​     指创建一个新对象，将原始对象的所有属性值递归复制到新对象中，包括嵌套对象。深拷贝确保新对象与原始对象完全独立，修改其中一个不会影响另一个

```javascript
// 深拷贝相当于下述代码
var a = {
    name: 'brynn',
    address: {
        provi: 'HN',
        city: 'CS'
    }
};
var b = {};
b.name = a.name;
b.address = {};
b.address.provi = a.address.provi;
b.address.city = a.address.city;
// 以下方式实现深拷贝
// JSON.parse(JSON.Stringify(Obj))
const a = {
  name: 'brynn',
  address: {
    province: 'hunan',
    city: 'changsha',
  },
}
const b = JSON.parse(JSON.stringify(a))
b.name = 'boolean'
b.address.province = 'shanxi'
console.log(a)
console.log(b)

```

## 3作用域与闭包

### 3.1作用域Scope

​    **规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问**

#### 3.1.1全局作用域

#### 3.1.2局部作用域（函数作用域）

#### 3.1.3块级作用域

​       用一对花括号（一个[代码块](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/block)）创建出来的作用域    在花括号中使用`let`和`const`声明的变量存在于块级作用域中，在花括号之外不能访问这些变量；var声明的变量不具有块级作用域，在花括号之外也能访问这些变量

### 3.2作用域链

​      **作用域链本质是底层的变量查找机制。当在JavaScript中使用一个变量时，首先JavaScript引擎会尝试在当前作用域下去寻找该变量，如果没有找到，再到他的上一层作用域进行寻找，以此类推直到找到该变量或已经到了全局作用域。如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错。******

### 3.3垃圾回收机制

   内存的生命周期：

​         1.内存分配：声明变量、函数、对象的时候，系统会自动为他们分配内存

​         2.内存使用

​         3.内存回收：使用完毕，有垃圾回收器自动回收不再使用的内存

​      局部变量的值不用了，会被自动回收掉

### 3.4闭包

​    闭包=内层函数+引用的外层函数变量

```javascript
function outer() {
    const a = 1
    function f() {
        console.log(a)
    }
}
```

​    好处：1让外部可以访问函数内部的变量,但不能改变变量的值  2让变量的值始终保持在内存中

​    坏处：耗费内存，使用不当造成内存溢出

​    应用：**数据私有 ，保证数据安全**

### 3.5变量生命周期

​     **变量从定义到销毁的时间范围**    局部变量在函数执行完毕后销毁、全局变量在页面关闭后销毁。

## 4WEB APIs

### 4.1DOM

​    文档对象模型，使用JS操作html元素

#### 4.1.1DOM树

​    将HTML文档以树状结构直观的表现出来，直观地体现了标签与标签之间的关系

![image-20230707144737008](C:\Users\巴黎\AppData\Roaming\Typora\typora-user-images\image-20230707144737008.png)

#### 4.1.2DOM对象

​    浏览器根据html标签生成的JS对象，html标签的属性变成DOM对象的属性，同时增加一些新的属性，如innerHTML等

#### 4.1.3获取DOM对象

- 根据CSS选择器来获取DOM元素   

```javascript
document.querySelector('#btn')   //获取匹配的第一个元素
document.querySelectorAll('ul li')   //获取匹配的所有元素，得到的是一个伪数组，没有pop()等方法
```

- 其他获取DOM元素的方法

```javascript
document.getElementById('btn')
document.getElementByTagName('btn')
document.getElementByClassName('btn')
```

#### 4.1.4修改DOM对象内容

- innerHTML

​     解析标签

```javascript
btn.innerHTML = '<h1>别点我</h1>'
```

- innerText

​     不解析标签

```javascript
btn.innerText = '别点我'
```

#### 4.1.5修改DOM对象属性

- 常用属性

```javascript
let img = document.querySelector('img')
img.src = './品优购项目/images/logo.png'
```

- 样式属性

```javascript
//通过style修改
btn.style.color = 'red'
btn.style.backgroundColor = 'pink'   //驼峰式命名的样式名
document.body.style.backgroundImage = `url(./images/${random}.jpg)`
//通过类名修改  会把原先的类名覆盖
.black {
    background-image: url(./品优购项目/images/减.png);
 }
btn.className = 'black'
//通过classList修改样式
btn.classList.add('black')
btn.classList.remove('black')
btn.classList.toggle('black')   有这个类就删掉，没这个类就加上
```

#### 4.1.6DOM节点

   DOM树中每一个节点，分为元素节点、属性节点、文本节点

- 查找节点   最近的父节点parentNode  所有子元素节点children  下一个兄弟节点nextElementSibling  上一个兄弟节点previousElementSibling
- 增加节点   createElement('标签名')  父元素.appendChild(DOM对象)或者父元素.insertBefore(要插入的DOM对象，父元素已有的子DOM对象)
- 克隆节点
- 删除节点

### 4.2事件

#### 4.2.1事件监听

​     元素对象.addEventListener('事件类型'，要执行的函数)

​     可以向同个元素添加多个同类型的事件句柄，如：两个 "click" 事件

​     可以使用 removeEventListener() 方法来移除事件的监听

#### 4.2.2事件类型

#### 4.2.3事件对象

```javascript
btn.addEventListener('onclick', function (e){
    alert(e)
})
```

### 4.3BOM

​     **浏览器窗口是window对象，是最大的全局对象，全局变量是 window 对象的属性，全局函数是 window 对象的方法**。

![image-20230708142148919](image-20230708142148919.png)

4.3.1window.screen

​       window.screen 对象包含有关用户屏幕的信息

- screen.availWidth - 可用的屏幕宽度
- screen.availHeight - 可用的屏幕高度

4.3.2window.location

​        用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面

- location.hostname 返回 web 主机的域名
- location.port 返回 web 主机的端口 （80 或 443）
- location.href 返回当前页面的URL
- location.protocol 返回所使用的 web 协议（http: 或 https:）
- location.assign 加载新的文档

4.3.3window.setInterval()和window.setTimeout()

4.3.4window.document

### 4.4JS执行机制

#### 4.4.1单线程

​    JS最大特点就是**单线程**，同一时间只能做一件事，所有任务需要排队，前一个任务结束，才能执行后一个任务。为了解决这个问题，出现了同步和异步

   不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。                

​    js在执行异步操作（文件读写、网络请求、计时器）时，浏览器会**单独开辟线程**去执行这些操作，当这些异步操作完成后，会将每个异步操作绑定的相应的回调函数放入任务队列里，等待js主线程中所有的任务结束，按次序读取任务队列中的回调函数，进入主线程，开始执行

​    比如setTimeout函数，由定时器线程计时，当时间到了后，计时完毕后，就会把回调函数放到任务队列里，等待主线程执行

![image-20231229151609611](image-20231229151609611.png)

#### 4.4.2同步异步任务

   **同步：**前一个任务结束后才能执行后一个任务。**同步是阻塞模式**，相当于是当客户端发送请求给服务端，在等待服务端响应的请求时，客户端不能做其他的事情。当服务端做完了才返回到客户端。这样的话客户端需要一直等待。

   **异步：进程不需要一直等下去，而是继续执行下面的操作****。**异步是非阻塞模式**，相当于当客户端发送给服务端请求时，**在等待服务端响应的时候，客户端可以做其他的事情

   **同步任务：** 指的是在js线程(主线程，js只有这一个线程)上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。
   **异步任务：** 指的是先不进入主线程，等主线程的任务执行完，该任务才会进入主线程执行。

#### 4.4.3事件循环（事件轮询）

​    事件循环是js实现异步的一种方法，也是js的执行机制

​    **执行机制：**

​         1同步的进入主线程，异步的进入Event Table并注册函数

​         2先执行执行栈中的同步任务 

​         3当指定的事情完成时，将异步任务放入事件队列中等待执行  比如setTimeout(f(),t)等t时刻之后将异步任务f()放入事件队列中去

​         4一旦执行栈中的所有同步任务执行完毕，会按次序读取事件队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行

​         5重复上述过程，即常说的事件循环



![img](https://img-blog.csdnimg.cn/20200316135437335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fsb2trYQ==,size_16,color_FFFFFF,t_70)

#### 4.4.4process.nextTick()与setImmediate()

​      process.nextTick()：同步代码执行之后，异步代码执行之前执行

​      setImmediate()：当前事件循环结束之后

#### 4.4.5宏任务与微任务

​      **异步任务**又包括**宏任务（macrotask ）和微任务（microtask ）**    

​      宏任务：计时器、ajax、读取文件

​      微任务：promise.then

​      宏任务进入宏任务EventTable，微任务进入微任务EventTable

​      执行顺序：

​           1同步任务

​           2process.nextTick()

​           3微任务

​           4宏任务

​           5setImmediate()

![image-20231222183804753](image-20231222183804753.png)

### 执行机制：

##### 主线程任务——>微任务——>宏任务

如果宏任务里还有微任务就继续执行宏任务里的微任务，如果宏任务中的微任务中还有宏任务就在依次进行

##### 主线程任务——>微任务——>宏任务——>宏任务里的微任务——>宏任务里的微任务中的宏任务——>直到任务全部完成

![img](https://img-blog.csdnimg.cn/20200317002740234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fsb2trYQ==,size_16,color_FFFFFF,t_70)

### 4.5本地存储

- 数据存储在用户浏览器中
- localstorage:永久存储在本地

```javascript
//存储简单数据类型
localStorage.setItem('键'，'值')
localStorage.getItem('键')
localStorage.removeItem('键')
//存储复杂数据类型
let obj = {
    uname = 'adas',
    age: 17,
}
localStorage.setItem('obj'，JSON.stringify(obj))
JSON.parse(localStorage.getItem('obj'))
```

- sessionStorage:生命周期为关闭浏览器窗口，同一个页面下数据可以共享

## 5正则表达式

  匹配字符串中字符组合的模式，可用于匹配、替换、提取

## 6ES6+

6.1箭头函数**(重要)**

   引入目的：1更简短的函数写法   2不绑定this

```javascript
// 普通函数
const fn = function() {
    console.log(123)
}
// 箭头函数
// 基本语法
const fn = (x) => {
    console.log(x)
}
// 只有一个形参
const fn = x => {
    console.log(x)
}
// 只有一行代码，可以省略大括号
const fn = x => console.log(x)
// 函数体只有返回值,可以省略return和大括号
const fn = x => {
    return x + x
}
const fn = x => x + x
// 返回一个对象
const fn = uname => {
    return {uname: uname}
}
const fn = uname => ({uname})
```

​     **箭头函数不会创建自己的this，它只会找作用域链上一层的this** 

​     **DOM事件回调函数不推荐使用箭头函数，this会指向window**

### 6.2变量解构赋值

​     **ES6允许按照一定的模式从数组和对象中提取值并快速批量赋值给一系列变量**

​     主要分为数组的解构赋值和对象的解构赋值

#### 6.2.1数组的解构赋值

​      从数组中提取值，按照对应位置对应变量赋值，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就变成undefined

```javascript
// 基本用法
const [a, b, c] = [1, 2, 3]   //a 1  b 2  c 3
// 变量多单元值少
const [a, b, c] = [1, 2]  //c undefined
// 多级数组解构
const [a, b] = [1, [2, 3]] //b = [2, 3]
const [a, [b, c]] = [1, [2, 3]] //b 2
// 默认值  只在没有赋到值（即为undefined）生效，如果null，默认值不生效
const [x = 1] = [null] //x null
const [y = 1] = [undefined] //y 1
// 默认值是一个表达式 那么这个表达式是惰性求值（表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值）
const [x = 1, y = x] = [1]
```

#### 6.2.2对象的解构赋值

​      从对象中取值，按照相同属性名给变量赋值，只要等号两边的模式相同，左边的变量就会被赋予对应的值

```javascript
// 基本用法
const {bar, foo} = {
    foo: 'aaa',
    bar: 'bbb'
} // bar='bbb'  foo='aaa'
// {bar, foo}相当于{bar: bar, foo: foo}
const {foo: baz} = {
    foo: 'aaa',
    bar: 'bbb'
} // baz='aaa'
// 多级对象解构
const {p: [x, {y}]} = {
    p: ['hello', {y: 'world'}]
} //x='hello' y='world'
// 默认值 与数组类似
```

### 6.3构造函数

​    创建多个类似的对象

​    大写字母开头的函数，无需加return

​    通过new关键字来进行实例化

#### 6.3.1实例成员

#### 6.3.2静态成员

#### 6.3.3内置构造函数

- Number
- String
- Date
- Array
- Boolean
- ...

#### 6.3.4原型对象prototype

​    **js万物皆对象，对象分为函数对象和普通对象（除函数以外的对象），每个对象都有 __ proto_ _属性，但只有函数对象且非箭头函数才有prototype属性**

​    **js的每个函数（非箭头函数）在创建时，都会生成一个属性prototype，这个属性指向一个对象，这个对象就是此函数的原型对象。该原型对象有个属性constructor，指向该函数。**

```javascript
function Person() {}
// 说明：name,age,job这些本不应该放在原型上，只是为了说明属性查找机制
Person.prototype.name = "Nicholas"; 
Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; 
Person.prototype.sayName = function() { 
 console.log(this.name); 
};
let person1 = new Person()
let person2 = new Person()

// 构造函数有一个 prototype 属性引用其原型对象，而这个原型对象也有一个constructor 属性，引用这个构造函数
// 换句话说，两者循环引用
console.log(Person.prototype.constructor === Person); // true

// 构造函数、原型对象和实例是 3 个完全不同的对象
console.log(person1 !== Person); // true 
console.log(person1 !== Person.prototype); // true 
console.log(Person.prototype !== Person); // true

// 实例通过__proto__链接到原型对象，它实际上指向隐藏特性[[Prototype]] 
// 构造函数通过 prototype 属性链接到原型对象，实例与构造函数没有直接联系，与原型对象有直接联系，后面将会画图再次说明这个问题
console.log(person1.__proto__ === Person.prototype); // true 
conosle.log(person1.__proto__.constructor === Person); // true

// 同一个构造函数创建的两个实例，共享同一个原型对象 
console.log(person1.__proto__ === person2.__proto__); // true
```

​    公共属性写到构造函数里面，公共方法写到原型对象身上

​    作用：共享方法，减少内存浪费

  构造函数和原型对象中的this指向实例对象

#### 6.3.5对象原型 _ _proto_ _

​    **每次调用构造函数创建一个新实例，这个实例的 __ proto_ _属性就会指向构造函数的原型对象**



![image-20230708184432761](C:\Users\巴黎\AppData\Roaming\Typora\typora-user-images\image-20230708184432761.png)

![image-20230708184619403](C:\Users\巴黎\AppData\Roaming\Typora\typora-user-images\image-20230708184619403.png)

#### 6.3.6原型链

​      当访问一个`对象`的某个属性或方法时，先在这个对象本身上查找，如果没有找到，则会通过它的`__proto__`隐式属性，找到它的`构造函数`的`原型对象`，如果还没有找到就会再在其`构造函数`的`原型对象`的`__proto__`中查找，一直找到`Object.prototype.__proto__`这样一层一层向上查找就会形成一个链式结构，我们称为`原型链`

​     每个构造函数都有一个prototype指向原型对象，原型对象有一个constructor属性指回构造函数，而实例有一个内部指针指向原型对象。如果原型对象是另一个构造函数的实例，那就意味着这个原型本身有一个内部指针指向另一个原型对象，相应的另一个原型对象也有一个指针指向另一个构造函数。这样实例和原型之间构成了一条原型链

​     原型链的尽头是`Object.prototype.__proto__`，为null

```javascript
function SuperType() {
  this.property = true;
}
SuperType.prototype.getSuperValue = function () {
  return this.property;
};
function SubType() {
  this.subproperty = false;
}
// 继承 SuperType 
SubType.prototype = new SuperType();
SubType.prototype.getSubValue = function () {
  return this.subproperty;
};
let instance = new SubType();
console.log(instance.getSuperValue()); // true
```

![image-20231217204926493](image-20231217204926493.png)

**所有函数包括构造函数都是Function()构造函数的实例，Function()的构造函数是其本身**

![image-20231217203751274](image-20231217203751274.png)

### 6.4var、let和const

  var的变量提升：**在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的行为。变量被提升后，会给变量设置默认值为 undefined**

  优先用const    

  基本数据类型，如果变量的值会发生变化，不可以用const，用let 比如for循环中的i++

  引用数据类型，栈中存储的是地址，而不是值   追加、修改元素的值，地址没发生改变，const声明就不会报错  **（建议数组和对象使用const来声明）**

let和const的区别：

- const声明的变量必须初始化，而let声明的变量不用
- const声明的变量不可以通过再赋值修改，也不能再次声明。而let定义的变量值可以
- const声明的变量如果是引用数据类型，可以追加或修改元素的值

### 6.5Set和Map数据结构

#### 6.5.1Map数据结构

​    相比于obj  ①有序   ②任何值都可以作为键（obj键自动变成字符串）  ③不会触发原型链的查找

```javascript
// 初始化
let myMap = new Map()
// 初始化时传入数据    二维列表
let myMap = new Map([['name', '张三'], ['age', 20]])
// 插入数据
myMap.set('name', '123')
myMap.set(123, '会飞的朱猪'）
myMap.set({}, '知乎')
// 获取长度
let myMap = myMap.size
// 获取值
mayMap.get(123)
// 删除某个键值对
myMap.delete('name')
// 判断某个值是否存在
myMap.has('name')
```

#### 6.5.2Set数据结构

​      相对于数组  ①存储任何类型  ②唯一值

```javascript
// 初始化
let mySet = new Set()
// 初始化时传入数据    一维列表
let mySet = new Set(['123', {p: 123}])
// 插入数据
mySet.add(123)
```

### 6.6对象扩展和新增方法

#### 6.6.1对象扩展

①属性的简介表示法

```javascript
const baz = {foo}; 
//等同于
const baz = {foo：foo};
```

②属性名表达式

​    允许用表达式作为对象的属性名，即把表达式放在方括号内

```javascript
let propKey = 'foo';

let obj = {
  [propKey]: true,
  ['a' + 'bc']: 123
};
```

③扩展运算符

```javascript
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
```

6.6.2对象的新增方法

①Object.assign()

②__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()

③Object.keys()，Object.values()，Object.entries()、Object.fromEntries()

Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。
Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。

### 6.7默认参数和剩余参数

​    剩余参数永远是个数组，即使没有值，也是空数组；而arguments是一个伪数组

​    剩余参数只能是最后一个参数，之后不能再有其他参数，否则会报错

```javascript
const add = (x, y, ...args) => {
    console.log(x, y, args);  //打印剩余参数的时候不要加...
};
add(1, 2, 3, 4, 5);   // [3, 4, 5]
```

## 7JSON

​     数据交换格式，是服务器端与客户端之间进行数据传输与交换的格式

​     JSON的优点是可以**简单灵活**地表示树形结构的数据   比XML更加简单

​     本质是[字符串]

```javascript
// JSON对象
var str2 = { "name": "有课前端网", "url": "htttps://www.webqdkf.com" };
// JSON字符串
var str1 = '{ "name": "有课前端网", "url": "htttps://www.webqdkf.com" }';
var str3 = '[{ "name": "有课前端网", "url": "htttps://www.webqdkf.com" },
             { "name": "有课前端网2", "url": "htttps://www.webqdkf2.com" }]';
```

  「JSON 字符串」的全称是「符合 JSON 语法的字符串」   「JSON 对象」的全称是「符合 JSON 对象语法的字符串」

1. JSON.parse 的作用是把「符合 JSON 语法的字符串」变成「JS 里的数据结构」
2. JSON.stringify 的作用是把「JS 里的数据结构」变成「符合 JSON 语法的字符串」

## 8Promise & async / await 异步编程

### 8.1Promise的理解和使用

#### 8.1.1理解

- 抽象表达

​        JS中进行异步编程的新解决方案  **旧方案单纯使用回调函数实现异步**(将函数A作为参数传递给函数B时，称函数A为回调函数，我们需要等待函数B的函数体，成功执行函数A后，再执行回调函数B

```javascript
// 旧方案异步编程
// fs文件操作
require('fs').readFile('./index.html', (err, data)=>{})
// 数据库操作
// AJAX
$.get('/server', (data)=>{})
// 定时器
setTimeout(()=>{}, 2000)
```

- 具体表达

​        Promise()是一个构造函数

​        promise对象用来封装一个异步操作并可以获取其成功或失败的结果值

#### 8.1.2为什么使用Promise

- 支持链式调用，可以解决回调地狱问题（回调地狱不便于阅读，不便于异常处理）
- 指定回调函数的方式更加灵活
- 用链式结构将多个异步操作串联起来

#### 8.1.3初体验

```javascript
const p = new Promise((resolve, reject) => {
    setTimeout(() => {
        let n = rand(1, 100);
        if(n <= 30){
            resolve(n);
        }else{
            reject(n);
        }
    }, 1000);
})

p.then((value) => {
    alert('恭喜恭喜，奖评为10万元劳斯莱斯优惠券，您的中奖数字为' + value);
}, (reason) => {
    alert('再接再厉，您的号码为' + reason);
})
```

#### 8.1.4封装AJAX请求

```javascript
function sendAJAX(url, method) {
    return new Promise((resolve, reject) => {
    const xhr =new XMLHttpRequest();
    xhr,open(method, url)
    xhr.send()
    xhr.onreadystatechange = function() {
        if(xhr.readyState == 4){
            if(...){
               resolve(xhr.response)
               }
               else{
                   reject(xhr.status)
               }
        }
    }
})
}

sendAJAX(' ', ' ').then((value) => {
    console.log(value);
}, (reason) => {
    console.log(reason);
})
```

### 8.2Promise对象属性和方法

#### 8.2.1状态PromiseState

**只能修改一次**

- pending   未决定的
- resolve/fulfilled  成功
- rejected   失败

#### 8.2.2Promise对象的值PromiseResult

保存着对象成功/失败的值

#### 8.2.3Promise构造函数   

返回一个Promise对象，对象的状态和属性取决于resolve()和rejected() 未使用两者则为pending undefined

Promise(excutor)，**同步任务**

- executor函数：执行器（resolve, reject） => {}
- resolve函数
- reject函数

#### 8.2.4Promise.prototype.then()：（onResolved, onRejected）=> {}   

返回一个新的Promise对象，对象的属性和状态取决于回调函数的执行结果决定

- onResolved函数：成功的回调函数
- onRejected函数：失败的回调函数

#### 8.2.5Promise.prototype.catch方法：(onRejected) => {}   

返回一个新的Promise对象，对象的属性和状态取决于回调函数的执行结果决定

- onRejected函数：失败的回调函数

#### 8.2.6Promise.resolve()   返回一个Promise对象  

- 普通值，返回的对象状态为成功 值为普通值
- Promise对象，与Promise对象的状态一致  值为Promise对象的值

#### 8.2.7Promise.rejected()   返回一个Promise对象

​       返回的Promise状态均为失败

#### 8.2.8Promise.all(Promise[])  返回一个Promise对象

​       Promise[]:Promise数组，存放的均为Promise对象，所有对象均成功返回的Promise对象状态才为成功，返回的Promise对象值为Promise数组中各Promise对象值的数组；反之亦然，同时返回的Promise对象值为Promise数组中失败对象的值

#### 8.2.8Promise.race（Promise[]）  返回一个Promise对象

​       返回的Promise对象状态和值为Promise数组中第一个完成的promise状态和值

### 8.3Promise的工作流程

![image-20231226193425049](image-20231226193425049.png)

### 8.4几个关键问题

#### 8.4.1改变Promise对象状态的方式

- resolve()
- rejected()
- throw()

#### 8.4.2一个Promise对象指定多个回调函数，都会调用吗

  当Promise对象的状态改变时，都会调用对应的回调函数

#### 8.4.3 Promise.then()返回的新Promise的结果状态由什么决定

​    由回调函数的执行结果决定

- 抛出错误throw()    状态失败 值为抛出的异常值
- 返回非Promise类型对象  状态成功 值为返回值 如果没有返回值，则为undefined
- 返回Promise类型对象  与其一致

#### 8.4.4promise异常穿透

​     当使用Promise的then链式调用时，可以在最后指定失败的回调，无需为每一个then方法指定失败的回调

```javascript
const p = new Promise((resolve, rejected) => {
    setTimeout(() => {
        console.log(111);
    }, 1000)
    resolve("OK")
})
p.then((value) => {
    console.log(222);
    throw('111')
}).then((value) => {
    console.log(333);
}).catch((reason) => {
    console.log(reason)
})
```

#### 8.4.5终止Promise链的唯一方法

​      返回一个pending状态的Promise对象  return new Promise(() => {})

### 8.5手写Promise

### 8.6async函数

- 函数的返回值为Promise对象
- Promise对象的结果由函数的返回值决定   返回值如果是一个非Promise对象；返回Promise对象

### 8.7await表达式

- await右侧的表达式为Promise对象或其他值
- 如果表达式是Promise对象，**await 返回Promise 成功 的值**
- 如果表达式是其他值，直接将这个值作为await的返回值

注意：await必须写在async函数中，但async可以没有await    如果await的Promise失败了，就会抛出异常

